//! PDF report generation.
//!
//! Generates PDF reports for scan results.
//! Uses a simple text-based PDF format for portability.

use crate::core::error::Result;
use crate::core::types::ScanSummary;
use std::fs::File;
use std::io::Write;
use std::path::Path;

/// PDF report generator.
pub struct PdfReporter {
    /// Page width in points (72 points = 1 inch)
    page_width: f32,
    /// Page height in points
    page_height: f32,
    /// Margin in points
    margin: f32,
}

impl PdfReporter {
    /// Create a new PDF reporter with US Letter size.
    pub fn new() -> Self {
        Self {
            page_width: 612.0,  // 8.5 inches
            page_height: 792.0, // 11 inches
            margin: 72.0,       // 1 inch
        }
    }

    /// Generate a PDF report.
    pub fn generate(&self, summary: &ScanSummary, output_path: &Path) -> Result<()> {
        let mut file = File::create(output_path)?;

        // Build content lines
        let mut lines = Vec::new();

        lines.push("PC-Peroxide Scan Report".to_string());
        lines.push("=".repeat(60));
        lines.push(String::new());

        lines.push(format!("Scan ID:        {}", summary.scan_id));
        lines.push(format!("Scan Type:      {}", summary.scan_type));
        lines.push(format!("Status:         {:?}", summary.status));
        lines.push(format!("Start Time:     {}", summary.start_time.format("%Y-%m-%d %H:%M:%S")));
        if let Some(end_time) = summary.end_time {
            lines.push(format!("End Time:       {}", end_time.format("%Y-%m-%d %H:%M:%S")));
        }
        lines.push(String::new());

        lines.push("Statistics".to_string());
        lines.push("-".repeat(40));
        lines.push(format!("Files Scanned:  {}", summary.files_scanned));
        lines.push(format!("Data Scanned:   {}", Self::format_bytes(summary.bytes_scanned)));
        lines.push(format!("Threats Found:  {}", summary.threats_found));
        lines.push(format!("Errors:         {}", summary.errors));
        if let Some(duration) = summary.duration_secs() {
            lines.push(format!("Duration:       {} seconds", duration));
            if summary.files_scanned > 0 && duration > 0 {
                let rate = summary.files_scanned as f64 / duration as f64;
                lines.push(format!("Scan Rate:      {:.1} files/sec", rate));
            }
        }
        lines.push(String::new());

        lines.push("Detections".to_string());
        lines.push("-".repeat(40));

        if summary.detections.is_empty() {
            lines.push("No threats detected.".to_string());
        } else {
            for (i, det) in summary.detections.iter().enumerate() {
                lines.push(format!("{}. [{}] {}", i + 1, det.severity, det.threat_name));
                lines.push(format!("   Category: {}", det.category));
                lines.push(format!("   Path: {}", det.path.display()));
                if !det.description.is_empty() {
                    lines.push(format!("   {}", det.description));
                }
                lines.push(String::new());
            }
        }

        lines.push(String::new());
        lines.push("-".repeat(60));
        lines.push(format!("Generated by PC-Peroxide v{}", env!("CARGO_PKG_VERSION")));
        lines.push(format!("Report generated at {}", chrono::Local::now().format("%Y-%m-%d %H:%M:%S")));

        // Write PDF
        self.write_pdf(&mut file, &lines)?;

        Ok(())
    }

    /// Write a simple PDF document.
    fn write_pdf(&self, file: &mut File, lines: &[String]) -> Result<()> {
        let _content_width = self.page_width - (2.0 * self.margin);
        let content_height = self.page_height - (2.0 * self.margin);
        let line_height = 14.0;
        let font_size = 10.0;
        let lines_per_page = (content_height / line_height) as usize;

        // Split into pages
        let pages: Vec<&[String]> = lines.chunks(lines_per_page).collect();
        let num_pages = pages.len();

        // PDF Header
        writeln!(file, "%PDF-1.4")?;
        // Binary marker (indicates binary content)
        file.write_all(b"%\xE2\xE3\xCF\xD3\n")?;

        let mut objects = Vec::new();
        let mut obj_positions = Vec::new();

        // Catalog (object 1)
        let pos = Self::file_position(file)?;
        obj_positions.push(pos);
        objects.push(format!(
            "1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n"
        ));
        write!(file, "{}", objects.last().unwrap())?;

        // Pages (object 2)
        let pos = Self::file_position(file)?;
        obj_positions.push(pos);
        let kids: Vec<String> = (0..num_pages).map(|i| format!("{} 0 R", 4 + i * 2)).collect();
        objects.push(format!(
            "2 0 obj\n<< /Type /Pages /Kids [{}] /Count {} >>\nendobj\n",
            kids.join(" "),
            num_pages
        ));
        write!(file, "{}", objects.last().unwrap())?;

        // Font (object 3)
        let pos = Self::file_position(file)?;
        obj_positions.push(pos);
        objects.push(
            "3 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Courier >>\nendobj\n".to_string(),
        );
        write!(file, "{}", objects.last().unwrap())?;

        // Generate page objects
        let mut current_obj = 4;
        for (page_num, page_lines) in pages.iter().enumerate() {
            // Page object
            let pos = Self::file_position(file)?;
            obj_positions.push(pos);
            objects.push(format!(
                "{} 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 {} {}] /Resources << /Font << /F1 3 0 R >> >> /Contents {} 0 R >>\nendobj\n",
                current_obj,
                self.page_width,
                self.page_height,
                current_obj + 1
            ));
            write!(file, "{}", objects.last().unwrap())?;
            current_obj += 1;

            // Content stream
            let mut stream = String::new();
            stream.push_str("BT\n");
            stream.push_str(&format!("/F1 {} Tf\n", font_size));

            let start_y = self.page_height - self.margin;

            for (line_num, line) in page_lines.iter().enumerate() {
                let y = start_y - (line_num as f32 * line_height);
                let escaped_line = Self::escape_pdf_string(line);
                stream.push_str(&format!(
                    "{} {} Td ({}) Tj\n",
                    if line_num == 0 { self.margin } else { 0.0 },
                    if line_num == 0 { y } else { -line_height },
                    escaped_line
                ));
            }

            stream.push_str("ET\n");

            // Add page number
            stream.push_str("BT\n");
            stream.push_str(&format!("/F1 {} Tf\n", font_size - 2.0));
            stream.push_str(&format!(
                "{} {} Td (Page {} of {}) Tj\n",
                self.page_width / 2.0 - 30.0,
                self.margin / 2.0,
                page_num + 1,
                num_pages
            ));
            stream.push_str("ET\n");

            let pos = Self::file_position(file)?;
            obj_positions.push(pos);
            objects.push(format!(
                "{} 0 obj\n<< /Length {} >>\nstream\n{}endstream\nendobj\n",
                current_obj,
                stream.len(),
                stream
            ));
            write!(file, "{}", objects.last().unwrap())?;
            current_obj += 1;
        }

        // Cross-reference table
        let xref_pos = Self::file_position(file)?;
        writeln!(file, "xref")?;
        writeln!(file, "0 {}", obj_positions.len() + 1)?;
        writeln!(file, "0000000000 65535 f ")?;
        for pos in &obj_positions {
            writeln!(file, "{:010} 00000 n ", pos)?;
        }

        // Trailer
        writeln!(file, "trailer")?;
        writeln!(
            file,
            "<< /Size {} /Root 1 0 R >>",
            obj_positions.len() + 1
        )?;
        writeln!(file, "startxref")?;
        writeln!(file, "{}", xref_pos)?;
        writeln!(file, "%%EOF")?;

        Ok(())
    }

    /// Get current file position.
    fn file_position(file: &File) -> Result<u64> {
        use std::io::Seek;
        let mut file = file;
        Ok(file.stream_position()?)
    }

    /// Escape PDF string special characters.
    fn escape_pdf_string(s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('(', "\\(")
            .replace(')', "\\)")
    }

    /// Format bytes for display.
    fn format_bytes(bytes: u64) -> String {
        const KB: u64 = 1024;
        const MB: u64 = KB * 1024;
        const GB: u64 = MB * 1024;

        if bytes >= GB {
            format!("{:.2} GB", bytes as f64 / GB as f64)
        } else if bytes >= MB {
            format!("{:.2} MB", bytes as f64 / MB as f64)
        } else if bytes >= KB {
            format!("{:.2} KB", bytes as f64 / KB as f64)
        } else {
            format!("{} bytes", bytes)
        }
    }
}

impl Default for PdfReporter {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_pdf_string() {
        assert_eq!(PdfReporter::escape_pdf_string("test"), "test");
        assert_eq!(PdfReporter::escape_pdf_string("(test)"), "\\(test\\)");
        assert_eq!(PdfReporter::escape_pdf_string("back\\slash"), "back\\\\slash");
    }

    #[test]
    fn test_format_bytes() {
        assert_eq!(PdfReporter::format_bytes(500), "500 bytes");
        assert_eq!(PdfReporter::format_bytes(1024), "1.00 KB");
        assert_eq!(PdfReporter::format_bytes(1024 * 1024), "1.00 MB");
    }

    #[test]
    fn test_reporter_creation() {
        let reporter = PdfReporter::new();
        assert_eq!(reporter.page_width, 612.0);
        assert_eq!(reporter.page_height, 792.0);
        assert_eq!(reporter.margin, 72.0);
    }
}
